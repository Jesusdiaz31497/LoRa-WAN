// ------------------    LIBRARIES FOR OLED    --------------------
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>
Adafruit_SSD1306 oled(128, 32, &Wire, -1);

// ------------------    LIBRARIES FOR SD    --------------------

#include <SD.h>
File archivo;

// ------------------  LIBRARIES FOR LORA    --------------------

#include <lmic.h>
#include <hal/hal.h>
#include <SPI.h>

//-------------------  VARIABLES GLOBALES    --------------------

uint8_t   NWKSKEY[16], APPSKEY[16], KEY[16], tx_payload[7];
uint32_t  DEVADDR;

bool      flag_timer, flag_ext1, flag_ext2;
uint16_t  Ext2, Ext1, Consumo, Min;

static const unsigned char PROGMEM image_data_Cenicana[] = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf0, 0x1f, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xe0, 0x07, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xc0, 0x03, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x80, 0x01, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x00, 0x00, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x00, 0x00, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x00, 0x00, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x80, 0x03, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x80, 0x07, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xc0, 0x0f, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xe0, 0x1f, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf8, 0x3f, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// ------------------- LMIC - PIN USED ---------------------------

void os_getArtEui (u1_t* buf) { }
void os_getDevEui (u1_t* buf) { }
void os_getDevKey (u1_t* buf) { }
static osjob_t sendjob;

const lmic_pinmap lmic_pins = {
  .nss = 18,
  .rxtx = LMIC_UNUSED_PIN,
  .rst = 23,
  .dio = {26, 33, 32},
};

#define Led  25
#define S1   4
#define S2   0

// ------------------ INTERRUPCION TIMER OVF -------------------

hw_timer_t *My_timer = NULL;

void IRAM_ATTR onTimer() {
  flag_timer = true;
}

// ------------------ SPI INIT ---------------------------------

SPIClass hspi(HSPI);
SPIClass vspi(VSPI);

// ------------------ INTERRPCION EXTERNA   --------------------

void IRAM_ATTR Sensor1() {
  flag_ext1 = true;
  
}

void IRAM_ATTR Sensor2() {
  flag_ext2 = true;
}


void setup() {

  //OLED initialization
  if (!oled.begin(SSD1306_SWITCHCAPVCC, 0x3C)) {
    Serial.println(F("SSD1306 allocation failed"));
    for (;;);                                                 // Don't proceed, loop forever
  }

  oled.clearDisplay();            // clear display
  oled.setTextSize(1);            // set text size
  oled.setTextColor(WHITE);       // set text color
  
  oled.clearDisplay();                
  oled.drawBitmap(0, 0, image_data_Cenicana, 128, 24, SSD1306_WHITE);
  oled.setCursor(40, 24);
  oled.println("Cenicana");
  oled.display();

  SPI.end();
  pinMode(18, OUTPUT);
  pinMode(13, OUTPUT);

  Serial.begin(115200);
  pinMode(Led,  OUTPUT); digitalWrite(Led, LOW);
  pinMode(18, OUTPUT);   pinMode(13, OUTPUT);

  str_key("17FD4903C02AAE4D2A8B5D8B6E9655B3");                      // LEER PARAMETROS LORAWAN
  memcpy_P(NWKSKEY, KEY, 16);

  str_key("7D464AD6BD678CE39B3CF360FD5C5B6C");
  memcpy_P(APPSKEY, KEY, 16);

  str_DEVADDR("3025B84E");

  Init_Lora();

  pinMode(S1, INPUT_PULLUP);
  pinMode(S2, INPUT_PULLUP);
  attachInterrupt(digitalPinToInterrupt(S1), Sensor1, FALLING);             // FALLING RISING CHANGE  HIGH  LOW
  attachInterrupt(digitalPinToInterrupt(S2), Sensor2, FALLING);             // FALLING RISING CHANGE  HIGH  LOW

  My_timer = timerBegin(0, 80, true);
  timerAttachInterrupt(My_timer, &onTimer, true);
  timerAlarmWrite(My_timer, 60000000, true);
  timerAlarmEnable(My_timer);

  hspi.begin(14, 2, 15, 13);
  if (!SD.begin(13, hspi)) {
    Serial.println("FAILED SD !!");
    return;
  }
  archivo = SD.open("/datos.txt", FILE_APPEND);

  if (archivo) {
    archivo.print("Min "); archivo.print("Sensor 1 "); archivo.print("Sensor 2 "); archivo.println("Consumo");
    archivo.close();
  }

}

void loop() {
  os_runloop_once();

  if (flag_timer) {
    Consumo += abs(Ext2 - Ext1);
    Min++;
    Payload ();
    do_send(&sendjob);
    Sd_save();
    Data_print();
    Data_oled();
    flag_timer = false; Ext2  = 0;  Ext1 = 0;
  }

  if(flag_ext2){
    delayMicroseconds(10);
    Ext2++;
    flag_ext2 = false;
  }

  if(flag_ext1){
    delayMicroseconds(10);
    Ext1++;
    flag_ext1 = false;
  }


}

void Sd_save() {

  if (!SD.begin(13, hspi)) {
    Serial.println("FAILED SD !!");
    return;
  } archivo = SD.open("/datos.txt", FILE_APPEND);

  if (archivo) {
    archivo.print(Min); archivo.print(' ');  archivo.print(Ext2);  archivo.print(' '); archivo.print(Ext1); archivo.print(' '); archivo.println(Consumo);
    archivo.close();
  } else {
    Serial.println("FALLO ESCRITURA !!");
  }
}

void Payload () {
  tx_payload[0] = (Consumo >> 8) & 0x00FF;
  tx_payload[1] =  Consumo & 0x00FF;

  tx_payload[2] = (Ext1 >> 8) & 0x00FF;
  tx_payload[3] =  Ext1 & 0x00FF;

  tx_payload[4] = (Ext2 >> 8) & 0x00FF;
  tx_payload[5] =  Ext2 & 0x00FF;

  tx_payload[6] = Min;
}

void Data_print(){
  Serial.print(Min); Serial.print(' ');  Serial.print(Ext2);  Serial.print(' '); Serial.print(Ext1); Serial.print(' '); Serial.println(Consumo);
}

void Data_oled(){
  oled.clearDisplay();

  oled.drawBitmap(0, 0, image_data_Cenicana, 128, 24, SSD1306_WHITE);
  oled.setCursor(40, 24);
  oled.println("Cenicana");
  oled.display();
  delay(2000);

  oled.clearDisplay();
        
  oled.setCursor(0, 0);
  oled.println("Min:");
  oled.setCursor(30, 0);
  oled.println(Min);

  oled.setCursor(0, 8);
  oled.println("S1:");
  oled.setCursor(30, 8);
  oled.println(Ext2);

  oled.setCursor(0, 16);
  oled.println("S2:");
  oled.setCursor(30, 16);
  oled.println(Ext1);

  oled.setCursor(0, 24);
  oled.println("Con:");
  oled.setCursor(30, 24);
  oled.println(Consumo);

  oled.display();
}
